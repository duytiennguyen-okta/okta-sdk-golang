/*
Okta Admin Management

Allows customers to easily access the Okta Management APIs

Copyright 2018 - Present Okta, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

API version: 4.0.0
Contact: devex-public@okta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.
package okta

import (
	"encoding/json"
	"fmt"
)

// NotificationType the model 'NotificationType'
type NotificationType string

// List of NotificationType
const (
	NOTIFICATIONTYPE_AD_AGENT                       NotificationType = "AD_AGENT"
	NOTIFICATIONTYPE_APP_IMPORT                     NotificationType = "APP_IMPORT"
	NOTIFICATIONTYPE_CONNECTOR_AGENT                NotificationType = "CONNECTOR_AGENT"
	NOTIFICATIONTYPE_IWA_AGENT                      NotificationType = "IWA_AGENT"
	NOTIFICATIONTYPE_LDAP_AGENT                     NotificationType = "LDAP_AGENT"
	NOTIFICATIONTYPE_OKTA_ANNOUNCEMENT              NotificationType = "OKTA_ANNOUNCEMENT"
	NOTIFICATIONTYPE_OKTA_ISSUE                     NotificationType = "OKTA_ISSUE"
	NOTIFICATIONTYPE_OKTA_UPDATE                    NotificationType = "OKTA_UPDATE"
	NOTIFICATIONTYPE_RATELIMIT_NOTIFICATION         NotificationType = "RATELIMIT_NOTIFICATION"
	NOTIFICATIONTYPE_REPORT_SUSPICIOUS_ACTIVITY     NotificationType = "REPORT_SUSPICIOUS_ACTIVITY"
	NOTIFICATIONTYPE_USER_DEPROVISION               NotificationType = "USER_DEPROVISION"
	NOTIFICATIONTYPE_USER_LOCKED_OUT                NotificationType = "USER_LOCKED_OUT"
	NOTIFICATIONTYPE_AGENT_AUTO_UPDATE_NOTIFICATION NotificationType = "AGENT_AUTO_UPDATE_NOTIFICATION"
)

// All allowed values of NotificationType enum
var AllowedNotificationTypeEnumValues = []NotificationType{
	"AD_AGENT",
	"APP_IMPORT",
	"CONNECTOR_AGENT",
	"IWA_AGENT",
	"LDAP_AGENT",
	"OKTA_ANNOUNCEMENT",
	"OKTA_ISSUE",
	"OKTA_UPDATE",
	"RATELIMIT_NOTIFICATION",
	"REPORT_SUSPICIOUS_ACTIVITY",
	"USER_DEPROVISION",
	"USER_LOCKED_OUT",
	"AGENT_AUTO_UPDATE_NOTIFICATION",
}

func (v *NotificationType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := NotificationType(value)
	for _, existing := range AllowedNotificationTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid NotificationType", value)
}

// NewNotificationTypeFromValue returns a pointer to a valid NotificationType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewNotificationTypeFromValue(v string) (*NotificationType, error) {
	ev := NotificationType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for NotificationType: valid values are %v", v, AllowedNotificationTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v NotificationType) IsValid() bool {
	for _, existing := range AllowedNotificationTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to NotificationType value
func (v NotificationType) Ptr() *NotificationType {
	return &v
}

type NullableNotificationType struct {
	value *NotificationType
	isSet bool
}

func (v NullableNotificationType) Get() *NotificationType {
	return v.value
}

func (v *NullableNotificationType) Set(val *NotificationType) {
	v.value = val
	v.isSet = true
}

func (v NullableNotificationType) IsSet() bool {
	return v.isSet
}

func (v *NullableNotificationType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableNotificationType(val *NotificationType) *NullableNotificationType {
	return &NullableNotificationType{value: val, isSet: true}
}

func (v NullableNotificationType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableNotificationType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
